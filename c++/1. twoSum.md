 there is 3 solution for this problem, 
 1. sorting is first sort, than use 2 pointer to compare
 2. the second and third are both hashmap and both use the compare target-nums[i] and nums[i] in the same step to reduce the time, but the difference is 2 pass take 2 for loop and 1 pass only need 1 for loop, 1 pass 跟2 pass 是一樣的事情, 但是1pass 寫在同一個loop

1.  sorting
first sort than 2 indecators, one point to the greatest value, the other point to the smallest, and ++ or -- if the sum of these 2 is bigger or smaller to target.
* pair is a c++ class, .first and .second is data fields for ```pair``` not a function call, so no (). 
 ```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // sorting solution
        // create a pair<int, int> vector A
        //      pair<num[i], i> <value, index> 

        vector<pair<int,int>> A;

        // add everything in nums into A

        for(int i=0; i<nums.size(); i++){
            A.push_back( {nums[i], i} );
        }
        // sort A base on value
        sort(A.begin(), A.end());

        // 
        int i=0, j=nums.size() -1;
        while(i<j){
            int temp = A[i].first +A[j].first;
            if(temp == target){
                return { min( A[i].second, A[j].second), max( A[i].second, A[j].second) };
            } else if( temp > target){
                j--;
            } else if( temp < target){
                i++;
            }
        } 
        return {};
    }
};
```
 2. hashmap( 2 pass ) 2 for loop, the first loop through nums to get the entire hashmap ready, the second compare
find the diff between target and nums[i], use 
```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // hashmap 2 pass
        unordered_map<int, int> indices;

        const int n = nums.size();

        // put the vlaue in hashmap
        for(int i=0; i<n; i++){
            indices[nums[i]] = i;
        }

        // 
        for(int i=0; i<n; i++){
            int diff = target - nums[i];
            if(indices.count(diff) && indices[diff] != i ){
                return {i, indices[diff]};
            }
        }
        return {};


    }     
};
```
3. hashmap (one pass) only loop through the nums once, also find the diff between target and nums[i] first compare than insert in the same loop. 
```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // hashmap 2 pass
        unordered_map<int, int> seen;
        const int n = nums.size();

        // the same one compare, 
        for(int i=0; i<n; i++){
            int diff = target - nums[i];
            if(seen.count(diff) && seen[diff] != i){
                return {seen[diff], i };
            }
            // insert
            seen.insert({ nums[i], i});

        }
        return {};

    }     
};
```
