 there is a lot of solution for this problem, 

1.  sorting
first sort than 2 indecators, one point to the greatest value, the other point to the smallest, and ++ or -- if the sum of these 2 is bigger or smaller to target.
* pair is a c++ class, .first and .second is data fields for ```pair``` not a function call, so no (). 
 ```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // sorting solution
        // create a pair<int, int> vector A
        //      pair<num[i], i> <value, index> 

        vector<pair<int,int>> A;

        // add everything in nums into A

        for(int i=0; i<nums.size(); i++){
            A.push_back( {nums[i], i} );
        }
        // sort A base on value
        sort(A.begin(), A.end());

        // 
        int i=0, j=nums.size() -1;
        while(i<j){
            int temp = A[i].first +A[j].first;
            if(temp == target){
                return { min( A[i].second, A[j].second), max( A[i].second, A[j].second) };
            } else if( temp > target){
                j--;
            } else if( temp < target){
                i++;
            }
        } 
        return {};
    }
};
```
 2. hashmap( 2 pass )
find the diff between target and nums[i]
```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // hashmap 2 pass
        unordered_map<int, int> indices;

        const int n = nums.size();

        // put the vlaue in hashmap
        for(int i=0; i<n; i++){
            indices[nums[i]] = i;
        }

        // 
        for(int i=0; i<n; i++){
            int diff = target - nums[i];
            if(indices.count(diff) && indices[diff] != i ){
                return {i, indices[diff]};
            }
        }
        return {};


    }     
};
```
